<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Gson</a> &gt; <a href="index.source.html" class="el_package">com.google.gson.stream</a> &gt; <span class="el_source">JsonWriter.java</span></div><h1>JsonWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2010 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.stream;

import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.io.Writer;

import static com.google.gson.stream.JsonScope.DANGLING_NAME;
import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;
import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;
import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;
import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;
import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;
import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;

/**
 * Writes a JSON (&lt;a href=&quot;http://www.ietf.org/rfc/rfc7159.txt&quot;&gt;RFC 7159&lt;/a&gt;)
 * encoded value to a stream, one token at a time. The stream includes both
 * literal values (strings, numbers, booleans and nulls) as well as the begin
 * and end delimiters of objects and arrays.
 *
 * &lt;h3&gt;Encoding JSON&lt;/h3&gt;
 * To encode your data as JSON, create a new {@code JsonWriter}. Each JSON
 * document must contain one top-level array or object. Call methods on the
 * writer as you walk the structure's contents, nesting arrays and objects as
 * necessary:
 * &lt;ul&gt;
 *   &lt;li&gt;To write &lt;strong&gt;arrays&lt;/strong&gt;, first call {@link #beginArray()}.
 *       Write each of the array's elements with the appropriate {@link #value}
 *       methods or by nesting other arrays and objects. Finally close the array
 *       using {@link #endArray()}.
 *   &lt;li&gt;To write &lt;strong&gt;objects&lt;/strong&gt;, first call {@link #beginObject()}.
 *       Write each of the object's properties by alternating calls to
 *       {@link #name} with the property's value. Write property values with the
 *       appropriate {@link #value} method or by nesting other objects or arrays.
 *       Finally close the object using {@link #endObject()}.
 * &lt;/ul&gt;
 *
 * &lt;h3&gt;Example&lt;/h3&gt;
 * Suppose we'd like to encode a stream of messages such as the following: &lt;pre&gt; {@code
 * [
 *   {
 *     &quot;id&quot;: 912345678901,
 *     &quot;text&quot;: &quot;How do I stream JSON in Java?&quot;,
 *     &quot;geo&quot;: null,
 *     &quot;user&quot;: {
 *       &quot;name&quot;: &quot;json_newb&quot;,
 *       &quot;followers_count&quot;: 41
 *      }
 *   },
 *   {
 *     &quot;id&quot;: 912345678902,
 *     &quot;text&quot;: &quot;@json_newb just use JsonWriter!&quot;,
 *     &quot;geo&quot;: [50.454722, -104.606667],
 *     &quot;user&quot;: {
 *       &quot;name&quot;: &quot;jesse&quot;,
 *       &quot;followers_count&quot;: 2
 *     }
 *   }
 * ]}&lt;/pre&gt;
 * This code encodes the above structure: &lt;pre&gt;   {@code
 *   public void writeJsonStream(OutputStream out, List&lt;Message&gt; messages) throws IOException {
 *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, &quot;UTF-8&quot;));
 *     writer.setIndent(&quot;    &quot;);
 *     writeMessagesArray(writer, messages);
 *     writer.close();
 *   }
 *
 *   public void writeMessagesArray(JsonWriter writer, List&lt;Message&gt; messages) throws IOException {
 *     writer.beginArray();
 *     for (Message message : messages) {
 *       writeMessage(writer, message);
 *     }
 *     writer.endArray();
 *   }
 *
 *   public void writeMessage(JsonWriter writer, Message message) throws IOException {
 *     writer.beginObject();
 *     writer.name(&quot;id&quot;).value(message.getId());
 *     writer.name(&quot;text&quot;).value(message.getText());
 *     if (message.getGeo() != null) {
 *       writer.name(&quot;geo&quot;);
 *       writeDoublesArray(writer, message.getGeo());
 *     } else {
 *       writer.name(&quot;geo&quot;).nullValue();
 *     }
 *     writer.name(&quot;user&quot;);
 *     writeUser(writer, message.getUser());
 *     writer.endObject();
 *   }
 *
 *   public void writeUser(JsonWriter writer, User user) throws IOException {
 *     writer.beginObject();
 *     writer.name(&quot;name&quot;).value(user.getName());
 *     writer.name(&quot;followers_count&quot;).value(user.getFollowersCount());
 *     writer.endObject();
 *   }
 *
 *   public void writeDoublesArray(JsonWriter writer, List&lt;Double&gt; doubles) throws IOException {
 *     writer.beginArray();
 *     for (Double value : doubles) {
 *       writer.value(value);
 *     }
 *     writer.endArray();
 *   }}&lt;/pre&gt;
 *
 * &lt;p&gt;Each {@code JsonWriter} may be used to write a single JSON stream.
 * Instances of this class are not thread safe. Calls that would result in a
 * malformed JSON string will fail with an {@link IllegalStateException}.
 *
 * @author Jesse Wilson
 * @since 1.6
 */
public class JsonWriter implements Closeable, Flushable {

  /*
   * From RFC 7159, &quot;All Unicode characters may be placed within the
   * quotation marks except for the characters that must be escaped:
   * quotation mark, reverse solidus, and the control characters
   * (U+0000 through U+001F).&quot;
   *
   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
   * newline characters. This prevents eval() from failing with a syntax
   * error. http://code.google.com/p/google-gson/issues/detail?id=341
   */
  private static final String[] REPLACEMENT_CHARS;
  private static final String[] HTML_SAFE_REPLACEMENT_CHARS;
  static {
<span class="fc" id="L145">    REPLACEMENT_CHARS = new String[128];</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">    for (int i = 0; i &lt;= 0x1f; i++) {</span>
<span class="fc" id="L147">      REPLACEMENT_CHARS[i] = String.format(&quot;\\u%04x&quot;, (int) i);</span>
    }
<span class="fc" id="L149">    REPLACEMENT_CHARS['&quot;'] = &quot;\\\&quot;&quot;;</span>
<span class="fc" id="L150">    REPLACEMENT_CHARS['\\'] = &quot;\\\\&quot;;</span>
<span class="fc" id="L151">    REPLACEMENT_CHARS['\t'] = &quot;\\t&quot;;</span>
<span class="fc" id="L152">    REPLACEMENT_CHARS['\b'] = &quot;\\b&quot;;</span>
<span class="fc" id="L153">    REPLACEMENT_CHARS['\n'] = &quot;\\n&quot;;</span>
<span class="fc" id="L154">    REPLACEMENT_CHARS['\r'] = &quot;\\r&quot;;</span>
<span class="fc" id="L155">    REPLACEMENT_CHARS['\f'] = &quot;\\f&quot;;</span>
<span class="fc" id="L156">    HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();</span>
<span class="fc" id="L157">    HTML_SAFE_REPLACEMENT_CHARS['&lt;'] = &quot;\\u003c&quot;;</span>
<span class="fc" id="L158">    HTML_SAFE_REPLACEMENT_CHARS['&gt;'] = &quot;\\u003e&quot;;</span>
<span class="fc" id="L159">    HTML_SAFE_REPLACEMENT_CHARS['&amp;'] = &quot;\\u0026&quot;;</span>
<span class="fc" id="L160">    HTML_SAFE_REPLACEMENT_CHARS['='] = &quot;\\u003d&quot;;</span>
<span class="fc" id="L161">    HTML_SAFE_REPLACEMENT_CHARS['\''] = &quot;\\u0027&quot;;</span>
<span class="fc" id="L162">  }</span>

  /** The output data, containing at most one top-level array or object. */
  private final Writer out;

<span class="fc" id="L167">  private int[] stack = new int[32];</span>
<span class="fc" id="L168">  private int stackSize = 0;</span>
  {
<span class="fc" id="L170">    push(EMPTY_DOCUMENT);</span>
  }

  /**
   * A string containing a full set of spaces for a single level of
   * indentation, or null for no pretty printing.
   */
  private String indent;

  /**
   * The name/value separator; either &quot;:&quot; or &quot;: &quot;.
   */
<span class="fc" id="L182">  private String separator = &quot;:&quot;;</span>

  private boolean lenient;

  private boolean htmlSafe;

  private String deferredName;

<span class="fc" id="L190">  private boolean serializeNulls = true;</span>

  /**
   * Creates a new instance that writes a JSON-encoded stream to {@code out}.
   * For best performance, ensure {@link Writer} is buffered; wrapping in
   * {@link java.io.BufferedWriter BufferedWriter} if necessary.
   */
<span class="fc" id="L197">  public JsonWriter(Writer out) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (out == null) {</span>
<span class="nc" id="L199">      throw new NullPointerException(&quot;out == null&quot;);</span>
    }
<span class="fc" id="L201">    this.out = out;</span>
<span class="fc" id="L202">  }</span>

  /**
   * Sets the indentation string to be repeated for each level of indentation
   * in the encoded document. If {@code indent.isEmpty()} the encoded document
   * will be compact. Otherwise the encoded document will be more
   * human-readable.
   *
   * @param indent a string containing only whitespace.
   */
  public final void setIndent(String indent) {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">    if (indent.length() == 0) {</span>
<span class="nc" id="L214">      this.indent = null;</span>
<span class="nc" id="L215">      this.separator = &quot;:&quot;;</span>
    } else {
<span class="fc" id="L217">      this.indent = indent;</span>
<span class="fc" id="L218">      this.separator = &quot;: &quot;;</span>
    }
<span class="fc" id="L220">  }</span>

  /**
   * Configure this writer to relax its syntax rules. By default, this writer
   * only emits well-formed JSON as specified by &lt;a
   * href=&quot;http://www.ietf.org/rfc/rfc7159.txt&quot;&gt;RFC 7159&lt;/a&gt;. Setting the writer
   * to lenient permits the following:
   * &lt;ul&gt;
   *   &lt;li&gt;Top-level values of any type. With strict writing, the top-level
   *       value must be an object or an array.
   *   &lt;li&gt;Numbers may be {@link Double#isNaN() NaNs} or {@link
   *       Double#isInfinite() infinities}.
   * &lt;/ul&gt;
   */
  public final void setLenient(boolean lenient) {
<span class="fc" id="L235">    this.lenient = lenient;</span>
<span class="fc" id="L236">  }</span>

  /**
   * Returns true if this writer has relaxed syntax rules.
   */
  public boolean isLenient() {
<span class="fc" id="L242">    return lenient;</span>
  }

  /**
   * Configure this writer to emit JSON that's safe for direct inclusion in HTML
   * and XML documents. This escapes the HTML characters {@code &lt;}, {@code &gt;},
   * {@code &amp;} and {@code =} before writing them to the stream. Without this
   * setting, your XML/HTML encoder should replace these characters with the
   * corresponding escape sequences.
   */
  public final void setHtmlSafe(boolean htmlSafe) {
<span class="fc" id="L253">    this.htmlSafe = htmlSafe;</span>
<span class="fc" id="L254">  }</span>

  /**
   * Returns true if this writer writes JSON that's safe for inclusion in HTML
   * and XML documents.
   */
  public final boolean isHtmlSafe() {
<span class="fc" id="L261">    return htmlSafe;</span>
  }

  /**
   * Sets whether object members are serialized when their value is null.
   * This has no impact on array elements. The default is true.
   */
  public final void setSerializeNulls(boolean serializeNulls) {
<span class="fc" id="L269">    this.serializeNulls = serializeNulls;</span>
<span class="fc" id="L270">  }</span>

  /**
   * Returns true if object members are serialized when their value is null.
   * This has no impact on array elements. The default is true.
   */
  public final boolean getSerializeNulls() {
<span class="fc" id="L277">    return serializeNulls;</span>
  }

  /**
   * Begins encoding a new array. Each call to this method must be paired with
   * a call to {@link #endArray}.
   *
   * @return this writer.
   */
  public JsonWriter beginArray() throws IOException {
<span class="fc" id="L287">    writeDeferredName();</span>
<span class="fc" id="L288">    return open(EMPTY_ARRAY, &quot;[&quot;);</span>
  }

  /**
   * Ends encoding the current array.
   *
   * @return this writer.
   */
  public JsonWriter endArray() throws IOException {
<span class="fc" id="L297">    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, &quot;]&quot;);</span>
  }

  /**
   * Begins encoding a new object. Each call to this method must be paired
   * with a call to {@link #endObject}.
   *
   * @return this writer.
   */
  public JsonWriter beginObject() throws IOException {
<span class="fc" id="L307">    writeDeferredName();</span>
<span class="fc" id="L308">    return open(EMPTY_OBJECT, &quot;{&quot;);</span>
  }

  /**
   * Ends encoding the current object.
   *
   * @return this writer.
   */
  public JsonWriter endObject() throws IOException {
<span class="fc" id="L317">    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, &quot;}&quot;);</span>
  }

  /**
   * Enters a new scope by appending any necessary whitespace and the given
   * bracket.
   */
  private JsonWriter open(int empty, String openBracket) throws IOException {
<span class="fc" id="L325">    beforeValue();</span>
<span class="fc" id="L326">    push(empty);</span>
<span class="fc" id="L327">    out.write(openBracket);</span>
<span class="fc" id="L328">    return this;</span>
  }

  /**
   * Closes the current scope by appending any necessary whitespace and the
   * given bracket.
   */
  private JsonWriter close(int empty, int nonempty, String closeBracket)
      throws IOException {
<span class="fc" id="L337">    int context = peek();</span>
<span class="fc bfc" id="L338" title="All 4 branches covered.">    if (context != nonempty &amp;&amp; context != empty) {</span>
<span class="fc" id="L339">      throw new IllegalStateException(&quot;Nesting problem.&quot;);</span>
    }
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (deferredName != null) {</span>
<span class="fc" id="L342">      throw new IllegalStateException(&quot;Dangling name: &quot; + deferredName);</span>
    }

<span class="fc" id="L345">    stackSize--;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">    if (context == nonempty) {</span>
<span class="fc" id="L347">      newline();</span>
    }
<span class="fc" id="L349">    out.write(closeBracket);</span>
<span class="fc" id="L350">    return this;</span>
  }

  private void push(int newTop) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (stackSize == stack.length) {</span>
<span class="fc" id="L355">      int[] newStack = new int[stackSize * 2];</span>
<span class="fc" id="L356">      System.arraycopy(stack, 0, newStack, 0, stackSize);</span>
<span class="fc" id="L357">      stack = newStack;</span>
    }
<span class="fc" id="L359">    stack[stackSize++] = newTop;</span>
<span class="fc" id="L360">  }</span>

  /**
   * Returns the value on the top of the stack.
   */
  private int peek() {
<span class="fc bfc" id="L366" title="All 2 branches covered.">    if (stackSize == 0) {</span>
<span class="fc" id="L367">      throw new IllegalStateException(&quot;JsonWriter is closed.&quot;);</span>
    }
<span class="fc" id="L369">    return stack[stackSize - 1];</span>
  }

  /**
   * Replace the value on the top of the stack with the given value.
   */
  private void replaceTop(int topOfStack) {
<span class="fc" id="L376">    stack[stackSize - 1] = topOfStack;</span>
<span class="fc" id="L377">  }</span>

  /**
   * Encodes the property name.
   *
   * @param name the name of the forthcoming value. May not be null.
   * @return this writer.
   */
  public JsonWriter name(String name) throws IOException {
<span class="fc bfc" id="L386" title="All 2 branches covered.">    if (name == null) {</span>
<span class="fc" id="L387">      throw new NullPointerException(&quot;name == null&quot;);</span>
    }
<span class="fc bfc" id="L389" title="All 2 branches covered.">    if (deferredName != null) {</span>
<span class="fc" id="L390">      throw new IllegalStateException();</span>
    }
<span class="fc bfc" id="L392" title="All 2 branches covered.">    if (stackSize == 0) {</span>
<span class="fc" id="L393">      throw new IllegalStateException(&quot;JsonWriter is closed.&quot;);</span>
    }
<span class="fc" id="L395">    deferredName = name;</span>
<span class="fc" id="L396">    return this;</span>
  }

  private void writeDeferredName() throws IOException {
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (deferredName != null) {</span>
<span class="fc" id="L401">      beforeName();</span>
<span class="fc" id="L402">      string(deferredName);</span>
<span class="fc" id="L403">      deferredName = null;</span>
    }
<span class="fc" id="L405">  }</span>

  /**
   * Encodes {@code value}.
   *
   * @param value the literal string value, or null to encode a null literal.
   * @return this writer.
   */
  public JsonWriter value(String value) throws IOException {
<span class="fc bfc" id="L414" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L415">      return nullValue();</span>
    }
<span class="fc" id="L417">    writeDeferredName();</span>
<span class="fc" id="L418">    beforeValue();</span>
<span class="fc" id="L419">    string(value);</span>
<span class="fc" id="L420">    return this;</span>
  }

  /**
   * Writes {@code value} directly to the writer without quoting or
   * escaping.
   *
   * @param value the literal string value, or null to encode a null literal.
   * @return this writer.
   */
  public JsonWriter jsonValue(String value) throws IOException {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L432">      return nullValue();</span>
    }
<span class="fc" id="L434">    writeDeferredName();</span>
<span class="fc" id="L435">    beforeValue();</span>
<span class="fc" id="L436">    out.append(value);</span>
<span class="fc" id="L437">    return this;</span>
  }

  /**
   * Encodes {@code null}.
   *
   * @return this writer.
   */
  public JsonWriter nullValue() throws IOException {
<span class="fc bfc" id="L446" title="All 2 branches covered.">    if (deferredName != null) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">      if (serializeNulls) {</span>
<span class="fc" id="L448">        writeDeferredName();</span>
      } else {
<span class="fc" id="L450">        deferredName = null;</span>
<span class="fc" id="L451">        return this; // skip the name and the value</span>
      }
    }
<span class="fc" id="L454">    beforeValue();</span>
<span class="fc" id="L455">    out.write(&quot;null&quot;);</span>
<span class="fc" id="L456">    return this;</span>
  }

  /**
   * Encodes {@code value}.
   *
   * @return this writer.
   */
  public JsonWriter value(boolean value) throws IOException {
<span class="fc" id="L465">    writeDeferredName();</span>
<span class="fc" id="L466">    beforeValue();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">    out.write(value ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="fc" id="L468">    return this;</span>
  }

  /**
   * Encodes {@code value}.
   *
   * @return this writer.
   */
  public JsonWriter value(Boolean value) throws IOException {
<span class="fc bfc" id="L477" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L478">      return nullValue();</span>
    }
<span class="fc" id="L480">    writeDeferredName();</span>
<span class="fc" id="L481">    beforeValue();</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">    out.write(value ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="fc" id="L483">    return this;</span>
  }

  /**
   * Encodes {@code value}.
   *
   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
   *     {@link Double#isInfinite() infinities}.
   * @return this writer.
   */
  public JsonWriter value(double value) throws IOException {
<span class="fc" id="L494">    writeDeferredName();</span>
<span class="fc bfc" id="L495" title="All 6 branches covered.">    if (!lenient &amp;&amp; (Double.isNaN(value) || Double.isInfinite(value))) {</span>
<span class="fc" id="L496">      throw new IllegalArgumentException(&quot;Numeric values must be finite, but was &quot; + value);</span>
    }
<span class="fc" id="L498">    beforeValue();</span>
<span class="fc" id="L499">    out.append(Double.toString(value));</span>
<span class="fc" id="L500">    return this;</span>
  }

  /**
   * Encodes {@code value}.
   *
   * @return this writer.
   */
  public JsonWriter value(long value) throws IOException {
<span class="fc" id="L509">    writeDeferredName();</span>
<span class="fc" id="L510">    beforeValue();</span>
<span class="fc" id="L511">    out.write(Long.toString(value));</span>
<span class="fc" id="L512">    return this;</span>
  }

  /**
   * Encodes {@code value}.
   *
   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or
   *     {@link Double#isInfinite() infinities}.
   * @return this writer.
   */
  public JsonWriter value(Number value) throws IOException {
<span class="fc bfc" id="L523" title="All 2 branches covered.">    if (value == null) {</span>
<span class="fc" id="L524">      return nullValue();</span>
    }

<span class="fc" id="L527">    writeDeferredName();</span>
<span class="fc" id="L528">    String string = value.toString();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">    if (!lenient</span>
<span class="fc bfc" id="L530" title="All 6 branches covered.">        &amp;&amp; (string.equals(&quot;-Infinity&quot;) || string.equals(&quot;Infinity&quot;) || string.equals(&quot;NaN&quot;))) {</span>
<span class="fc" id="L531">      throw new IllegalArgumentException(&quot;Numeric values must be finite, but was &quot; + value);</span>
    }
<span class="fc" id="L533">    beforeValue();</span>
<span class="fc" id="L534">    out.append(string);</span>
<span class="fc" id="L535">    return this;</span>
  }

  /**
   * Ensures all buffered data is written to the underlying {@link Writer}
   * and flushes that writer.
   */
  public void flush() throws IOException {
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">    if (stackSize == 0) {</span>
<span class="fc" id="L544">      throw new IllegalStateException(&quot;JsonWriter is closed.&quot;);</span>
    }
<span class="nc" id="L546">    out.flush();</span>
<span class="nc" id="L547">  }</span>

  /**
   * Flushes and closes this writer and the underlying {@link Writer}.
   *
   * @throws IOException if the JSON document is incomplete.
   */
  public void close() throws IOException {
<span class="fc" id="L555">    out.close();</span>

<span class="fc" id="L557">    int size = stackSize;</span>
<span class="pc bpc" id="L558" title="2 of 6 branches missed.">    if (size &gt; 1 || size == 1 &amp;&amp; stack[size - 1] != NONEMPTY_DOCUMENT) {</span>
<span class="nc" id="L559">      throw new IOException(&quot;Incomplete document&quot;);</span>
    }
<span class="fc" id="L561">    stackSize = 0;</span>
<span class="fc" id="L562">  }</span>

  private void string(String value) throws IOException {
<span class="fc bfc" id="L565" title="All 2 branches covered.">    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;</span>
<span class="fc" id="L566">    out.write(&quot;\&quot;&quot;);</span>
<span class="fc" id="L567">    int last = 0;</span>
<span class="fc" id="L568">    int length = value.length();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L570">      char c = value.charAt(i);</span>
      String replacement;
<span class="fc bfc" id="L572" title="All 2 branches covered.">      if (c &lt; 128) {</span>
<span class="fc" id="L573">        replacement = replacements[c];</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (replacement == null) {</span>
<span class="fc" id="L575">          continue;</span>
        }
<span class="fc bfc" id="L577" title="All 2 branches covered.">      } else if (c == '\u2028') {</span>
<span class="fc" id="L578">        replacement = &quot;\\u2028&quot;;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">      } else if (c == '\u2029') {</span>
<span class="fc" id="L580">        replacement = &quot;\\u2029&quot;;</span>
      } else {
        continue;
      }
<span class="fc bfc" id="L584" title="All 2 branches covered.">      if (last &lt; i) {</span>
<span class="fc" id="L585">        out.write(value, last, i - last);</span>
      }
<span class="fc" id="L587">      out.write(replacement);</span>
<span class="fc" id="L588">      last = i + 1;</span>
    }
<span class="fc bfc" id="L590" title="All 2 branches covered.">    if (last &lt; length) {</span>
<span class="fc" id="L591">      out.write(value, last, length - last);</span>
    }
<span class="fc" id="L593">    out.write(&quot;\&quot;&quot;);</span>
<span class="fc" id="L594">  }</span>

  private void newline() throws IOException {
<span class="fc bfc" id="L597" title="All 2 branches covered.">    if (indent == null) {</span>
<span class="fc" id="L598">      return;</span>
    }

<span class="fc" id="L601">    out.write(&quot;\n&quot;);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">    for (int i = 1, size = stackSize; i &lt; size; i++) {</span>
<span class="fc" id="L603">      out.write(indent);</span>
    }
<span class="fc" id="L605">  }</span>

  /**
   * Inserts any necessary separators and whitespace before a name. Also
   * adjusts the stack to expect the name's value.
   */
  private void beforeName() throws IOException {
<span class="fc" id="L612">    int context = peek();</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">    if (context == NONEMPTY_OBJECT) { // first in object</span>
<span class="fc" id="L614">      out.write(',');</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">    } else if (context != EMPTY_OBJECT) { // not in an object!</span>
<span class="fc" id="L616">      throw new IllegalStateException(&quot;Nesting problem.&quot;);</span>
    }
<span class="fc" id="L618">    newline();</span>
<span class="fc" id="L619">    replaceTop(DANGLING_NAME);</span>
<span class="fc" id="L620">  }</span>

  /**
   * Inserts any necessary separators and whitespace before a literal value,
   * inline array, or inline object. Also adjusts the stack to expect either a
   * closing bracket or another element.
   */
  @SuppressWarnings(&quot;fallthrough&quot;)
  private void beforeValue() throws IOException {
<span class="fc bfc" id="L629" title="All 6 branches covered.">    switch (peek()) {</span>
    case NONEMPTY_DOCUMENT:
<span class="fc bfc" id="L631" title="All 2 branches covered.">      if (!lenient) {</span>
<span class="fc" id="L632">        throw new IllegalStateException(</span>
            &quot;JSON must have only one top-level value.&quot;);
      }
      // fall-through
    case EMPTY_DOCUMENT: // first in document
<span class="fc" id="L637">      replaceTop(NONEMPTY_DOCUMENT);</span>
<span class="fc" id="L638">      break;</span>

    case EMPTY_ARRAY: // first in array
<span class="fc" id="L641">      replaceTop(NONEMPTY_ARRAY);</span>
<span class="fc" id="L642">      newline();</span>
<span class="fc" id="L643">      break;</span>

    case NONEMPTY_ARRAY: // another in array
<span class="fc" id="L646">      out.append(',');</span>
<span class="fc" id="L647">      newline();</span>
<span class="fc" id="L648">      break;</span>

    case DANGLING_NAME: // value for name
<span class="fc" id="L651">      out.append(separator);</span>
<span class="fc" id="L652">      replaceTop(NONEMPTY_OBJECT);</span>
<span class="fc" id="L653">      break;</span>

    default:
<span class="fc" id="L656">      throw new IllegalStateException(&quot;Nesting problem.&quot;);</span>
    }
<span class="fc" id="L658">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>