<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Plot.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JFreeChart</a> &gt; <a href="index.source.html" class="el_package">org.jfree.chart.plot</a> &gt; <span class="el_source">Plot.java</span></div><h1>Plot.java</h1><pre class="source lang-java linenums">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-present, by David Gilbert and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.
 * Other names may be trademarks of their respective owners.]
 *
 * ---------
 * Plot.java
 * ---------
 * (C) Copyright 2000-present, by David Gilbert and Contributors.
 *
 * Original Author:  David Gilbert;
 * Contributor(s):   Sylvain Vieujot;
 *                   Jeremy Bowman;
 *                   Andreas Schneider;
 *                   Gideon Krause;
 *                   Nicolas Brodu;
 *                   Michal Krause;
 *                   Richard West, Advanced Micro Devices, Inc.;
 *                   Peter Kolb - patches 2603321, 2809117;
 *                   Tracy Hiltbrand (equals/hashCode comply with EqualsVerifier);
 * 
 */

package org.jfree.chart.plot;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Paint;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Objects;

import javax.swing.event.EventListenerList;

import org.jfree.chart.JFreeChart;
import org.jfree.chart.LegendItemCollection;
import org.jfree.chart.LegendItemSource;
import org.jfree.chart.annotations.Annotation;
import org.jfree.chart.axis.AxisLocation;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.entity.PlotEntity;
import org.jfree.chart.event.AnnotationChangeEvent;
import org.jfree.chart.event.AnnotationChangeListener;
import org.jfree.chart.event.AxisChangeEvent;
import org.jfree.chart.event.AxisChangeListener;
import org.jfree.chart.event.ChartChangeEventType;
import org.jfree.chart.event.MarkerChangeEvent;
import org.jfree.chart.event.MarkerChangeListener;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.event.PlotChangeListener;
import org.jfree.chart.text.G2TextMeasurer;
import org.jfree.chart.text.TextBlock;
import org.jfree.chart.text.TextBlockAnchor;
import org.jfree.chart.text.TextUtils;
import org.jfree.chart.ui.Align;
import org.jfree.chart.ui.RectangleEdge;
import org.jfree.chart.ui.RectangleInsets;
import org.jfree.chart.util.ObjectUtils;
import org.jfree.chart.util.PaintUtils;
import org.jfree.chart.util.Args;
import org.jfree.chart.util.PublicCloneable;
import org.jfree.chart.util.SerialUtils;
import org.jfree.data.general.DatasetChangeEvent;
import org.jfree.data.general.DatasetChangeListener;
import org.jfree.data.general.DatasetGroup;

/**
 * The base class for all plots in JFreeChart.  The {@link JFreeChart} class
 * delegates the drawing of axes and data to the plot.  This base class
 * provides facilities common to most plot types.
 */
public abstract class Plot implements AxisChangeListener,
        DatasetChangeListener, AnnotationChangeListener, MarkerChangeListener,
        LegendItemSource, PublicCloneable, Cloneable, Serializable {

    /** For serialization. */
    private static final long serialVersionUID = -8831571430103671324L;

    /** Useful constant representing zero. */
<span class="fc" id="L115">    public static final Number ZERO = 0;</span>

    /** The default insets. */
<span class="fc" id="L118">    public static final RectangleInsets DEFAULT_INSETS</span>
            = new RectangleInsets(4.0, 8.0, 4.0, 8.0);

    /** The default outline stroke. */
<span class="fc" id="L122">    public static final Stroke DEFAULT_OUTLINE_STROKE = new BasicStroke(0.5f,</span>
            BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);

    /** The default outline color. */
<span class="fc" id="L126">    public static final Paint DEFAULT_OUTLINE_PAINT = Color.GRAY;</span>

    /** The default foreground alpha transparency. */
    public static final float DEFAULT_FOREGROUND_ALPHA = 1.0f;

    /** The default background alpha transparency. */
    public static final float DEFAULT_BACKGROUND_ALPHA = 1.0f;

    /** The default background color. */
<span class="fc" id="L135">    public static final Paint DEFAULT_BACKGROUND_PAINT = Color.WHITE;</span>

    /** The minimum width at which the plot should be drawn. */
    public static final int MINIMUM_WIDTH_TO_DRAW = 10;

    /** The minimum height at which the plot should be drawn. */
    public static final int MINIMUM_HEIGHT_TO_DRAW = 10;

    /** A default box shape for legend items. */
<span class="fc" id="L144">    public static final Shape DEFAULT_LEGEND_ITEM_BOX</span>
            = new Rectangle2D.Double(-4.0, -4.0, 8.0, 8.0);

    /** A default circle shape for legend items. */
<span class="fc" id="L148">    public static final Shape DEFAULT_LEGEND_ITEM_CIRCLE</span>
            = new Ellipse2D.Double(-4.0, -4.0, 8.0, 8.0);

    /** 
     * The chart that the plot is assigned to.  It can be {@code null} if the
     * plot is not assigned to a chart yet, or if the plot is a subplot of a
     * another plot.
     */
    private JFreeChart chart;
    
    /** The parent plot ({@code null} if this is the root plot). */
    private Plot parent;

    /** The dataset group (to be used for thread synchronisation). */
    private DatasetGroup datasetGroup;

    /** The message to display if no data is available. */
    private String noDataMessage;

    /** The font used to display the 'no data' message. */
    private Font noDataMessageFont;

    /** The paint used to draw the 'no data' message. */
    private transient Paint noDataMessagePaint;

    /** Amount of blank space around the plot area. */
    private RectangleInsets insets;

    /**
     * A flag that controls whether or not the plot outline is drawn.
     */
    private boolean outlineVisible;

    /** The Stroke used to draw an outline around the plot. */
    private transient Stroke outlineStroke;

    /** The Paint used to draw an outline around the plot. */
    private transient Paint outlinePaint;

    /** An optional color used to fill the plot background. */
    private transient Paint backgroundPaint;

    /** An optional image for the plot background. */
    private transient Image backgroundImage;  // not currently serialized

    /** The alignment for the background image. */
<span class="fc" id="L194">    private int backgroundImageAlignment = Align.FIT;</span>

    /** The alpha value used to draw the background image. */
<span class="fc" id="L197">    private float backgroundImageAlpha = 0.5f;</span>

    /** The alpha-transparency for the plot. */
    private float foregroundAlpha;

    /** The alpha transparency for the background paint. */
    private float backgroundAlpha;

    /** The drawing supplier. */
    private DrawingSupplier drawingSupplier;

    /** Storage for registered change listeners. */
    private transient EventListenerList listenerList;

    /**
     * A flag that controls whether or not the plot will notify listeners
     * of changes (defaults to true, but sometimes it is useful to disable
     * this).
     */
    private boolean notify;

    /**
     * Creates a new plot.
     */
<span class="fc" id="L221">    protected Plot() {</span>
<span class="fc" id="L222">        this.chart = null;</span>
<span class="fc" id="L223">        this.parent = null;</span>
<span class="fc" id="L224">        this.insets = DEFAULT_INSETS;</span>
<span class="fc" id="L225">        this.backgroundPaint = DEFAULT_BACKGROUND_PAINT;</span>
<span class="fc" id="L226">        this.backgroundAlpha = DEFAULT_BACKGROUND_ALPHA;</span>
<span class="fc" id="L227">        this.backgroundImage = null;</span>
<span class="fc" id="L228">        this.outlineVisible = true;</span>
<span class="fc" id="L229">        this.outlineStroke = DEFAULT_OUTLINE_STROKE;</span>
<span class="fc" id="L230">        this.outlinePaint = DEFAULT_OUTLINE_PAINT;</span>
<span class="fc" id="L231">        this.foregroundAlpha = DEFAULT_FOREGROUND_ALPHA;</span>

<span class="fc" id="L233">        this.noDataMessage = null;</span>
<span class="fc" id="L234">        this.noDataMessageFont = new Font(&quot;SansSerif&quot;, Font.PLAIN, 12);</span>
<span class="fc" id="L235">        this.noDataMessagePaint = Color.BLACK;</span>

<span class="fc" id="L237">        this.drawingSupplier = new DefaultDrawingSupplier();</span>

<span class="fc" id="L239">        this.notify = true;</span>
<span class="fc" id="L240">        this.listenerList = new EventListenerList();</span>
<span class="fc" id="L241">    }</span>
    
    /**
     * Returns the chart that this plot is assigned to.  This method can
     * return {@code null} if the plot is not yet assigned to a plot, or if the
     * plot is a subplot of another plot.
     * 
     * @return The chart (possibly {@code null}).
     */
    public JFreeChart getChart() {
<span class="nc" id="L251">        return this.chart;</span>
    }
    
    /**
     * Sets the chart that the plot is assigned to.  This method is not 
     * intended for external use.
     * 
     * @param chart  the chart ({@code null} permitted).
     */
    public void setChart(JFreeChart chart) {
<span class="fc" id="L261">        this.chart = chart;</span>
<span class="fc" id="L262">    }</span>
    
    /**
     * Fetches the element hinting flag from the chart that this plot is 
     * assigned to.  If the plot is not assigned (directly or indirectly) to
     * a chart instance, this method will return {@code false}.
     * 
     * @return A boolean.
     */
    public boolean fetchElementHintingFlag() {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (this.parent != null) {</span>
<span class="fc" id="L273">            return this.parent.fetchElementHintingFlag();</span>
        }
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (this.chart != null) {</span>
<span class="fc" id="L276">            return this.chart.getElementHinting();</span>
        }
<span class="nc" id="L278">        return false;</span>
    }

    /**
     * Returns the dataset group for the plot (not currently used).
     *
     * @return The dataset group.
     *
     * @see #setDatasetGroup(DatasetGroup)
     */
    public DatasetGroup getDatasetGroup() {
<span class="nc" id="L289">        return this.datasetGroup;</span>
    }

    /**
     * Sets the dataset group (not currently used).
     *
     * @param group  the dataset group ({@code null} permitted).
     *
     * @see #getDatasetGroup()
     */
    protected void setDatasetGroup(DatasetGroup group) {
<span class="fc" id="L300">        this.datasetGroup = group;</span>
<span class="fc" id="L301">    }</span>

    /**
     * Returns the string that is displayed when the dataset is empty or
     * {@code null}.
     *
     * @return The 'no data' message ({@code null} possible).
     *
     * @see #setNoDataMessage(String)
     * @see #getNoDataMessageFont()
     * @see #getNoDataMessagePaint()
     */
    public String getNoDataMessage() {
<span class="nc" id="L314">        return this.noDataMessage;</span>
    }

    /**
     * Sets the message that is displayed when the dataset is empty or
     * {@code null}, and sends a {@link PlotChangeEvent} to all registered
     * listeners.
     *
     * @param message  the message ({@code null} permitted).
     *
     * @see #getNoDataMessage()
     */
    public void setNoDataMessage(String message) {
<span class="fc" id="L327">        this.noDataMessage = message;</span>
<span class="fc" id="L328">        fireChangeEvent();</span>
<span class="fc" id="L329">    }</span>

    /**
     * Returns the font used to display the 'no data' message.
     *
     * @return The font (never {@code null}).
     *
     * @see #setNoDataMessageFont(Font)
     * @see #getNoDataMessage()
     */
    public Font getNoDataMessageFont() {
<span class="nc" id="L340">        return this.noDataMessageFont;</span>
    }

    /**
     * Sets the font used to display the 'no data' message and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param font  the font ({@code null} not permitted).
     *
     * @see #getNoDataMessageFont()
     */
    public void setNoDataMessageFont(Font font) {
<span class="fc" id="L352">        Args.nullNotPermitted(font, &quot;font&quot;);</span>
<span class="fc" id="L353">        this.noDataMessageFont = font;</span>
<span class="fc" id="L354">        fireChangeEvent();</span>
<span class="fc" id="L355">    }</span>

    /**
     * Returns the paint used to display the 'no data' message.
     *
     * @return The paint (never {@code null}).
     *
     * @see #setNoDataMessagePaint(Paint)
     * @see #getNoDataMessage()
     */
    public Paint getNoDataMessagePaint() {
<span class="nc" id="L366">        return this.noDataMessagePaint;</span>
    }

    /**
     * Sets the paint used to display the 'no data' message and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param paint  the paint ({@code null} not permitted).
     *
     * @see #getNoDataMessagePaint()
     */
    public void setNoDataMessagePaint(Paint paint) {
<span class="fc" id="L378">        Args.nullNotPermitted(paint, &quot;paint&quot;);</span>
<span class="fc" id="L379">        this.noDataMessagePaint = paint;</span>
<span class="fc" id="L380">        fireChangeEvent();</span>
<span class="fc" id="L381">    }</span>

    /**
     * Returns a short string describing the plot type.
     * &lt;P&gt;
     * Note: this gets used in the chart property editing user interface,
     * but there needs to be a better mechanism for identifying the plot type.
     *
     * @return A short string describing the plot type (never
     *     {@code null}).
     */
    public abstract String getPlotType();

    /**
     * Returns the parent plot (or {@code null} if this plot is not part
     * of a combined plot).
     *
     * @return The parent plot.
     *
     * @see #setParent(Plot)
     * @see #getRootPlot()
     */
    public Plot getParent() {
<span class="fc" id="L404">        return this.parent;</span>
    }

    /**
     * Sets the parent plot.  This method is intended for internal use, you
     * shouldn't need to call it directly.
     *
     * @param parent  the parent plot ({@code null} permitted).
     *
     * @see #getParent()
     */
    public void setParent(Plot parent) {
<span class="fc" id="L416">        this.parent = parent;</span>
<span class="fc" id="L417">    }</span>

    /**
     * Returns the root plot.
     *
     * @return The root plot.
     *
     * @see #getParent()
     */
    public Plot getRootPlot() {

<span class="nc" id="L428">        Plot p = getParent();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (p == null) {</span>
<span class="nc" id="L430">            return this;</span>
        }
<span class="nc" id="L432">        return p.getRootPlot();</span>

    }

    /**
     * Returns {@code true} if this plot is part of a combined plot
     * structure (that is, {@link #getParent()} returns a non-{@code null}
     * value), and {@code false} otherwise.
     *
     * @return {@code true} if this plot is part of a combined plot
     *         structure.
     *
     * @see #getParent()
     */
    public boolean isSubplot() {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        return (getParent() != null);</span>
    }

    /**
     * Returns the insets for the plot area.
     *
     * @return The insets (never {@code null}).
     *
     * @see #setInsets(RectangleInsets)
     */
    public RectangleInsets getInsets() {
<span class="fc" id="L458">        return this.insets;</span>
    }

    /**
     * Sets the insets for the plot and sends a {@link PlotChangeEvent} to
     * all registered listeners.
     *
     * @param insets  the new insets ({@code null} not permitted).
     *
     * @see #getInsets()
     * @see #setInsets(RectangleInsets, boolean)
     */
    public void setInsets(RectangleInsets insets) {
<span class="fc" id="L471">        setInsets(insets, true);</span>
<span class="fc" id="L472">    }</span>

    /**
     * Sets the insets for the plot and, if requested,  and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param insets  the new insets ({@code null} not permitted).
     * @param notify  a flag that controls whether the registered listeners are
     *                notified.
     *
     * @see #getInsets()
     * @see #setInsets(RectangleInsets)
     */
    public void setInsets(RectangleInsets insets, boolean notify) {
<span class="fc" id="L486">        Args.nullNotPermitted(insets, &quot;insets&quot;);</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (!this.insets.equals(insets)) {</span>
<span class="fc" id="L488">            this.insets = insets;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (notify) {</span>
<span class="fc" id="L490">                fireChangeEvent();</span>
            }
        }

<span class="fc" id="L494">    }</span>

    /**
     * Returns the background color of the plot area.
     *
     * @return The paint (possibly {@code null}).
     *
     * @see #setBackgroundPaint(Paint)
     */
    public Paint getBackgroundPaint() {
<span class="fc" id="L504">        return this.backgroundPaint;</span>
    }

    /**
     * Sets the background color of the plot area and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param paint  the paint ({@code null} permitted).
     *
     * @see #getBackgroundPaint()
     */
    public void setBackgroundPaint(Paint paint) {

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        if (paint == null) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (this.backgroundPaint != null) {</span>
<span class="nc" id="L519">                this.backgroundPaint = null;</span>
<span class="nc" id="L520">                fireChangeEvent();</span>
            }
        }
        else {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            if (this.backgroundPaint != null) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (this.backgroundPaint.equals(paint)) {</span>
<span class="nc" id="L526">                    return;  // nothing to do</span>
                }
            }
<span class="fc" id="L529">            this.backgroundPaint = paint;</span>
<span class="fc" id="L530">            fireChangeEvent();</span>
        }

<span class="fc" id="L533">    }</span>

    /**
     * Returns the alpha transparency of the plot area background.
     *
     * @return The alpha transparency.
     *
     * @see #setBackgroundAlpha(float)
     */
    public float getBackgroundAlpha() {
<span class="nc" id="L543">        return this.backgroundAlpha;</span>
    }

    /**
     * Sets the alpha transparency of the plot area background, and notifies
     * registered listeners that the plot has been modified.
     *
     * @param alpha the new alpha value (in the range 0.0f to 1.0f).
     *
     * @see #getBackgroundAlpha()
     */
    public void setBackgroundAlpha(float alpha) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        if (this.backgroundAlpha != alpha) {</span>
<span class="fc" id="L556">            this.backgroundAlpha = alpha;</span>
<span class="fc" id="L557">            fireChangeEvent();</span>
        }
<span class="fc" id="L559">    }</span>

    /**
     * Returns the drawing supplier for the plot.
     *
     * @return The drawing supplier (possibly {@code null}).
     *
     * @see #setDrawingSupplier(DrawingSupplier)
     */
    public DrawingSupplier getDrawingSupplier() {
        DrawingSupplier result;
<span class="fc" id="L570">        Plot p = getParent();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (p != null) {</span>
<span class="fc" id="L572">            result = p.getDrawingSupplier();</span>
        }
        else {
<span class="fc" id="L575">            result = this.drawingSupplier;</span>
        }
<span class="fc" id="L577">        return result;</span>
    }

    /**
     * Sets the drawing supplier for the plot and sends a
     * {@link PlotChangeEvent} to all registered listeners.  The drawing
     * supplier is responsible for supplying a limitless (possibly repeating)
     * sequence of {@code Paint}, {@code Stroke} and
     * {@code Shape} objects that the plot's renderer(s) can use to
     * populate its (their) tables.
     *
     * @param supplier  the new supplier.
     *
     * @see #getDrawingSupplier()
     */
    public void setDrawingSupplier(DrawingSupplier supplier) {
<span class="fc" id="L593">        this.drawingSupplier = supplier;</span>
<span class="fc" id="L594">        fireChangeEvent();</span>
<span class="fc" id="L595">    }</span>

    /**
     * Sets the drawing supplier for the plot and, if requested, sends a
     * {@link PlotChangeEvent} to all registered listeners.  The drawing
     * supplier is responsible for supplying a limitless (possibly repeating)
     * sequence of {@code Paint}, {@code Stroke} and
     * {@code Shape} objects that the plot's renderer(s) can use to
     * populate its (their) tables.
     *
     * @param supplier  the new supplier.
     * @param notify  notify listeners?
     *
     * @see #getDrawingSupplier()
     */
    public void setDrawingSupplier(DrawingSupplier supplier, boolean notify) {
<span class="nc" id="L611">        this.drawingSupplier = supplier;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (notify) {</span>
<span class="nc" id="L613">            fireChangeEvent();</span>
        }
<span class="nc" id="L615">    }</span>

    /**
     * Returns the background image that is used to fill the plot's background
     * area.
     *
     * @return The image (possibly {@code null}).
     *
     * @see #setBackgroundImage(Image)
     */
    public Image getBackgroundImage() {
<span class="nc" id="L626">        return this.backgroundImage;</span>
    }

    /**
     * Sets the background image for the plot and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param image  the image ({@code null} permitted).
     *
     * @see #getBackgroundImage()
     */
    public void setBackgroundImage(Image image) {
<span class="nc" id="L638">        this.backgroundImage = image;</span>
<span class="nc" id="L639">        fireChangeEvent();</span>
<span class="nc" id="L640">    }</span>

    /**
     * Returns the background image alignment. Alignment constants are defined
     * in the {@code Align} class.
     *
     * @return The alignment.
     *
     * @see #setBackgroundImageAlignment(int)
     */
    public int getBackgroundImageAlignment() {
<span class="nc" id="L651">        return this.backgroundImageAlignment;</span>
    }

    /**
     * Sets the alignment for the background image and sends a
     * {@link PlotChangeEvent} to all registered listeners.  Alignment options
     * are defined by the {@link org.jfree.chart.ui.Align} class.
     *
     * @param alignment  the alignment.
     *
     * @see #getBackgroundImageAlignment()
     */
    public void setBackgroundImageAlignment(int alignment) {
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        if (this.backgroundImageAlignment != alignment) {</span>
<span class="fc" id="L665">            this.backgroundImageAlignment = alignment;</span>
<span class="fc" id="L666">            fireChangeEvent();</span>
        }
<span class="fc" id="L668">    }</span>

    /**
     * Returns the alpha transparency used to draw the background image.  This
     * is a value in the range 0.0f to 1.0f, where 0.0f is fully transparent
     * and 1.0f is fully opaque.
     *
     * @return The alpha transparency.
     *
     * @see #setBackgroundImageAlpha(float)
     */
    public float getBackgroundImageAlpha() {
<span class="nc" id="L680">        return this.backgroundImageAlpha;</span>
    }

    /**
     * Sets the alpha transparency used when drawing the background image.
     *
     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f, where
     *     0.0f is fully transparent, and 1.0f is fully opaque).
     *
     * @throws IllegalArgumentException if {@code alpha} is not within
     *     the specified range.
     *
     * @see #getBackgroundImageAlpha()
     */
    public void setBackgroundImageAlpha(float alpha) {
<span class="pc bpc" id="L695" title="2 of 4 branches missed.">        if (alpha &lt; 0.0f || alpha &gt; 1.0f) {</span>
<span class="nc" id="L696">            throw new IllegalArgumentException(</span>
                    &quot;The 'alpha' value must be in the range 0.0f to 1.0f.&quot;);
        }
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (this.backgroundImageAlpha != alpha) {</span>
<span class="fc" id="L700">            this.backgroundImageAlpha = alpha;</span>
<span class="fc" id="L701">            fireChangeEvent();</span>
        }
<span class="fc" id="L703">    }</span>

    /**
     * Returns the flag that controls whether or not the plot outline is
     * drawn.  The default value is {@code true}.  Note that for
     * historical reasons, the plot's outline paint and stroke can take on
     * {@code null} values, in which case the outline will not be drawn
     * even if this flag is set to {@code true}.
     *
     * @return The outline visibility flag.
     *
     * @see #setOutlineVisible(boolean)
     */
    public boolean isOutlineVisible() {
<span class="fc" id="L717">        return this.outlineVisible;</span>
    }

    /**
     * Sets the flag that controls whether or not the plot's outline is
     * drawn, and sends a {@link PlotChangeEvent} to all registered listeners.
     *
     * @param visible  the new flag value.
     *
     * @see #isOutlineVisible()
     */
    public void setOutlineVisible(boolean visible) {
<span class="fc" id="L729">        this.outlineVisible = visible;</span>
<span class="fc" id="L730">        fireChangeEvent();</span>
<span class="fc" id="L731">    }</span>

    /**
     * Returns the stroke used to outline the plot area.
     *
     * @return The stroke (possibly {@code null}).
     *
     * @see #setOutlineStroke(Stroke)
     */
    public Stroke getOutlineStroke() {
<span class="nc" id="L741">        return this.outlineStroke;</span>
    }

    /**
     * Sets the stroke used to outline the plot area and sends a
     * {@link PlotChangeEvent} to all registered listeners. If you set this
     * attribute to {@code null}, no outline will be drawn.
     *
     * @param stroke  the stroke ({@code null} permitted).
     *
     * @see #getOutlineStroke()
     */
    public void setOutlineStroke(Stroke stroke) {
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (stroke == null) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (this.outlineStroke != null) {</span>
<span class="nc" id="L756">                this.outlineStroke = null;</span>
<span class="nc" id="L757">                fireChangeEvent();</span>
            }
        }
        else {
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">            if (this.outlineStroke != null) {</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">                if (this.outlineStroke.equals(stroke)) {</span>
<span class="nc" id="L763">                    return;  // nothing to do</span>
                }
            }
<span class="fc" id="L766">            this.outlineStroke = stroke;</span>
<span class="fc" id="L767">            fireChangeEvent();</span>
        }
<span class="fc" id="L769">    }</span>

    /**
     * Returns the color used to draw the outline of the plot area.
     *
     * @return The color (possibly {@code null}).
     *
     * @see #setOutlinePaint(Paint)
     */
    public Paint getOutlinePaint() {
<span class="nc" id="L779">        return this.outlinePaint;</span>
    }

    /**
     * Sets the paint used to draw the outline of the plot area and sends a
     * {@link PlotChangeEvent} to all registered listeners.  If you set this
     * attribute to {@code null}, no outline will be drawn.
     *
     * @param paint  the paint ({@code null} permitted).
     *
     * @see #getOutlinePaint()
     */
    public void setOutlinePaint(Paint paint) {
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        if (paint == null) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            if (this.outlinePaint != null) {</span>
<span class="nc" id="L794">                this.outlinePaint = null;</span>
<span class="nc" id="L795">                fireChangeEvent();</span>
            }
        }
        else {
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">            if (this.outlinePaint != null) {</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                if (this.outlinePaint.equals(paint)) {</span>
<span class="nc" id="L801">                    return;  // nothing to do</span>
                }
            }
<span class="fc" id="L804">            this.outlinePaint = paint;</span>
<span class="fc" id="L805">            fireChangeEvent();</span>
        }
<span class="fc" id="L807">    }</span>

    /**
     * Returns the alpha-transparency for the plot foreground.
     *
     * @return The alpha-transparency.
     *
     * @see #setForegroundAlpha(float)
     */
    public float getForegroundAlpha() {
<span class="fc" id="L817">        return this.foregroundAlpha;</span>
    }

    /**
     * Sets the alpha-transparency for the plot and sends a
     * {@link PlotChangeEvent} to all registered listeners.
     *
     * @param alpha  the new alpha transparency.
     *
     * @see #getForegroundAlpha()
     */
    public void setForegroundAlpha(float alpha) {
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">        if (this.foregroundAlpha != alpha) {</span>
<span class="fc" id="L830">            this.foregroundAlpha = alpha;</span>
<span class="fc" id="L831">            fireChangeEvent();</span>
        }
<span class="fc" id="L833">    }</span>

    /**
     * Returns the legend items for the plot.  By default, this method returns
     * {@code null}.  Subclasses should override to return a
     * {@link LegendItemCollection}.
     *
     * @return The legend items for the plot (possibly {@code null}).
     */
    @Override
    public LegendItemCollection getLegendItems() {
<span class="fc" id="L844">        return null;</span>
    }

    /**
     * Returns a flag that controls whether or not change events are sent to
     * registered listeners.
     *
     * @return A boolean.
     *
     * @see #setNotify(boolean)
     */
    public boolean isNotify() {
<span class="fc" id="L856">        return this.notify;</span>
    }

    /**
     * Sets a flag that controls whether or not listeners receive
     * {@link PlotChangeEvent} notifications.
     *
     * @param notify  a boolean.
     *
     * @see #isNotify()
     */
    public void setNotify(boolean notify) {
<span class="fc" id="L868">        this.notify = notify;</span>
        // if the flag is being set to true, there may be queued up changes...
<span class="fc bfc" id="L870" title="All 2 branches covered.">        if (notify) {</span>
<span class="fc" id="L871">            notifyListeners(new PlotChangeEvent(this));</span>
        }
<span class="fc" id="L873">    }</span>

    /**
     * Registers an object for notification of changes to the plot.
     *
     * @param listener  the object to be registered.
     *
     * @see #removeChangeListener(PlotChangeListener)
     */
    public void addChangeListener(PlotChangeListener listener) {
<span class="fc" id="L883">        this.listenerList.add(PlotChangeListener.class, listener);</span>
<span class="fc" id="L884">    }</span>

    /**
     * Unregisters an object for notification of changes to the plot.
     *
     * @param listener  the object to be unregistered.
     *
     * @see #addChangeListener(PlotChangeListener)
     */
    public void removeChangeListener(PlotChangeListener listener) {
<span class="fc" id="L894">        this.listenerList.remove(PlotChangeListener.class, listener);</span>
<span class="fc" id="L895">    }</span>

    /**
     * Notifies all registered listeners that the plot has been modified.
     *
     * @param event  information about the change event.
     */
    public void notifyListeners(PlotChangeEvent event) {
        // if the 'notify' flag has been switched to false, we don't notify
        // the listeners
<span class="fc bfc" id="L905" title="All 2 branches covered.">        if (!this.notify) {</span>
<span class="fc" id="L906">            return;</span>
        }
<span class="fc" id="L908">        Object[] listeners = this.listenerList.getListenerList();</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">            if (listeners[i] == PlotChangeListener.class) {</span>
<span class="fc" id="L911">                ((PlotChangeListener) listeners[i + 1]).plotChanged(event);</span>
            }
        }
<span class="fc" id="L914">    }</span>

    /**
     * Sends a {@link PlotChangeEvent} to all registered listeners.
     */
    protected void fireChangeEvent() {
<span class="fc" id="L920">        notifyListeners(new PlotChangeEvent(this));</span>
<span class="fc" id="L921">    }</span>

    /**
     * Draws the plot within the specified area.  The anchor is a point on the
     * chart that is specified externally (for instance, it may be the last
     * point of the last mouse click performed by the user) - plots can use or
     * ignore this value as they see fit.
     * &lt;br&gt;&lt;br&gt;
     * Subclasses need to provide an implementation of this method, obviously.
     *
     * @param g2  the graphics device.
     * @param area  the plot area.
     * @param anchor  the anchor point ({@code null} permitted).
     * @param parentState  the parent state (if any, {@code null} permitted).
     * @param info  carries back plot rendering info.
     */
    public abstract void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,
            PlotState parentState, PlotRenderingInfo info);

    /**
     * Draws the plot background (the background color and/or image).
     * &lt;P&gt;
     * This method will be called during the chart drawing process and is
     * declared public so that it can be accessed by the renderers used by
     * certain subclasses.  You shouldn't need to call this method directly.
     *
     * @param g2  the graphics device.
     * @param area  the area within which the plot should be drawn.
     */
    public void drawBackground(Graphics2D g2, Rectangle2D area) {
        // some subclasses override this method completely, so don't put
        // anything here that *must* be done
<span class="fc" id="L953">        fillBackground(g2, area);</span>
<span class="fc" id="L954">        drawBackgroundImage(g2, area);</span>
<span class="fc" id="L955">    }</span>

    /**
     * Fills the specified area with the background paint.
     *
     * @param g2  the graphics device.
     * @param area  the area.
     *
     * @see #getBackgroundPaint()
     * @see #getBackgroundAlpha()
     * @see #fillBackground(Graphics2D, Rectangle2D, PlotOrientation)
     */
    protected void fillBackground(Graphics2D g2, Rectangle2D area) {
<span class="fc" id="L968">        fillBackground(g2, area, PlotOrientation.VERTICAL);</span>
<span class="fc" id="L969">    }</span>

    /**
     * Fills the specified area with the background paint.  If the background
     * paint is an instance of {@code GradientPaint}, the gradient will
     * run in the direction suggested by the plot's orientation.
     *
     * @param g2  the graphics target.
     * @param area  the plot area.
     * @param orientation  the plot orientation ({@code null} not
     *         permitted).
     */
    protected void fillBackground(Graphics2D g2, Rectangle2D area,
            PlotOrientation orientation) {
<span class="fc" id="L983">        Args.nullNotPermitted(orientation, &quot;orientation&quot;);</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        if (this.backgroundPaint == null) {</span>
<span class="nc" id="L985">            return;</span>
        }
<span class="fc" id="L987">        Paint p = this.backgroundPaint;</span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">        if (p instanceof GradientPaint) {</span>
<span class="nc" id="L989">            GradientPaint gp = (GradientPaint) p;</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L991">                p = new GradientPaint((float) area.getCenterX(),</span>
<span class="nc" id="L992">                        (float) area.getMaxY(), gp.getColor1(),</span>
<span class="nc" id="L993">                        (float) area.getCenterX(), (float) area.getMinY(),</span>
<span class="nc" id="L994">                        gp.getColor2());</span>
            }
<span class="nc bnc" id="L996" title="All 2 branches missed.">            else if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L997">                p = new GradientPaint((float) area.getMinX(),</span>
<span class="nc" id="L998">                        (float) area.getCenterY(), gp.getColor1(),</span>
<span class="nc" id="L999">                        (float) area.getMaxX(), (float) area.getCenterY(),</span>
<span class="nc" id="L1000">                        gp.getColor2());</span>
            }
        }
<span class="fc" id="L1003">        Composite originalComposite = g2.getComposite();</span>
<span class="fc" id="L1004">        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</span>
                this.backgroundAlpha));
<span class="fc" id="L1006">        g2.setPaint(p);</span>
<span class="fc" id="L1007">        g2.fill(area);</span>
<span class="fc" id="L1008">        g2.setComposite(originalComposite);</span>
<span class="fc" id="L1009">    }</span>

    /**
     * Draws the background image (if there is one) aligned within the
     * specified area.
     *
     * @param g2  the graphics device.
     * @param area  the area.
     *
     * @see #getBackgroundImage()
     * @see #getBackgroundImageAlignment()
     * @see #getBackgroundImageAlpha()
     */
    public void drawBackgroundImage(Graphics2D g2, Rectangle2D area) {
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">        if (this.backgroundImage == null) {</span>
<span class="fc" id="L1024">            return;  // nothing to do</span>
        }
<span class="nc" id="L1026">        Composite savedComposite = g2.getComposite();</span>
<span class="nc" id="L1027">        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</span>
                this.backgroundImageAlpha));
<span class="nc" id="L1029">        Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,</span>
<span class="nc" id="L1030">                this.backgroundImage.getWidth(null),</span>
<span class="nc" id="L1031">                this.backgroundImage.getHeight(null));</span>
<span class="nc" id="L1032">        Align.align(dest, area, this.backgroundImageAlignment);</span>
<span class="nc" id="L1033">        Shape savedClip = g2.getClip();</span>
<span class="nc" id="L1034">        g2.clip(area);</span>
<span class="nc" id="L1035">        g2.drawImage(this.backgroundImage, (int) dest.getX(),</span>
<span class="nc" id="L1036">                (int) dest.getY(), (int) dest.getWidth() + 1,</span>
<span class="nc" id="L1037">                (int) dest.getHeight() + 1, null);</span>
<span class="nc" id="L1038">        g2.setClip(savedClip);</span>
<span class="nc" id="L1039">        g2.setComposite(savedComposite);</span>
<span class="nc" id="L1040">    }</span>

    /**
     * Draws the plot outline.  This method will be called during the chart
     * drawing process and is declared public so that it can be accessed by the
     * renderers used by certain subclasses. You shouldn't need to call this
     * method directly.
     *
     * @param g2  the graphics device.
     * @param area  the area within which the plot should be drawn.
     */
    public void drawOutline(Graphics2D g2, Rectangle2D area) {
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">        if (!this.outlineVisible) {</span>
<span class="nc" id="L1053">            return;</span>
        }
<span class="pc bpc" id="L1055" title="2 of 4 branches missed.">        if ((this.outlineStroke != null) &amp;&amp; (this.outlinePaint != null)) {</span>
<span class="fc" id="L1056">            g2.setStroke(this.outlineStroke);</span>
<span class="fc" id="L1057">            g2.setPaint(this.outlinePaint);</span>
<span class="fc" id="L1058">            Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);</span>
<span class="fc" id="L1059">            g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);</span>
<span class="fc" id="L1060">            g2.draw(area);</span>
<span class="fc" id="L1061">            g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);</span>
        }
<span class="fc" id="L1063">    }</span>

    /**
     * Draws a message to state that there is no data to plot.
     *
     * @param g2  the graphics device.
     * @param area  the area within which the plot should be drawn.
     */
    protected void drawNoDataMessage(Graphics2D g2, Rectangle2D area) {
<span class="fc" id="L1072">        Shape savedClip = g2.getClip();</span>
<span class="fc" id="L1073">        g2.clip(area);</span>
<span class="fc" id="L1074">        String message = this.noDataMessage;</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">        if (message != null) {</span>
<span class="nc" id="L1076">            g2.setFont(this.noDataMessageFont);</span>
<span class="nc" id="L1077">            g2.setPaint(this.noDataMessagePaint);</span>
<span class="nc" id="L1078">            TextBlock block = TextUtils.createTextBlock(</span>
                    this.noDataMessage, this.noDataMessageFont,
<span class="nc" id="L1080">                    this.noDataMessagePaint, 0.9f * (float) area.getWidth(),</span>
                    new G2TextMeasurer(g2));
<span class="nc" id="L1082">            block.draw(g2, (float) area.getCenterX(),</span>
<span class="nc" id="L1083">                    (float) area.getCenterY(), TextBlockAnchor.CENTER);</span>
        }
<span class="fc" id="L1085">        g2.setClip(savedClip);</span>
<span class="fc" id="L1086">    }</span>

    /**
     * Creates a plot entity that contains a reference to the plot and the
     * data area as shape.
     *
     * @param dataArea  the data area used as hot spot for the entity.
     * @param plotState  the plot rendering info containing a reference to the
     *     EntityCollection.
     * @param toolTip  the tool tip (defined in the respective Plot
     *     subclass) ({@code null} permitted).
     * @param urlText  the url (defined in the respective Plot subclass)
     *     ({@code null} permitted).
     */
    protected void createAndAddEntity(Rectangle2D dataArea,
            PlotRenderingInfo plotState, String toolTip, String urlText) {
<span class="fc bfc" id="L1102" title="All 4 branches covered.">        if (plotState != null &amp;&amp; plotState.getOwner() != null) {</span>
<span class="fc" id="L1103">            EntityCollection e = plotState.getOwner().getEntityCollection();</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">            if (e != null) {</span>
<span class="fc" id="L1105">                e.add(new PlotEntity(dataArea, this, toolTip, urlText));</span>
            }
        }
<span class="fc" id="L1108">    }</span>

    /**
     * Handles a 'click' on the plot.  Since the plot does not maintain any
     * information about where it has been drawn, the plot rendering info is
     * supplied as an argument so that the plot dimensions can be determined.
     *
     * @param x  the x coordinate (in Java2D space).
     * @param y  the y coordinate (in Java2D space).
     * @param info  an object containing information about the dimensions of
     *              the plot.
     */
    public void handleClick(int x, int y, PlotRenderingInfo info) {
        // provides a 'no action' default
<span class="nc" id="L1122">    }</span>

    /**
     * Performs a zoom on the plot.  Subclasses should override if zooming is
     * appropriate for the type of plot.
     *
     * @param percent  the zoom percentage.
     */
    public void zoom(double percent) {
        // do nothing by default.
<span class="nc" id="L1132">    }</span>

    /**
     * Receives notification of a change to an {@link Annotation} added to
     * this plot.
     *
     * @param event  information about the event (not used here).
     */
    @Override
    public void annotationChanged(AnnotationChangeEvent event) {
<span class="nc" id="L1142">        fireChangeEvent();</span>
<span class="nc" id="L1143">    }</span>

    /**
     * Receives notification of a change to one of the plot's axes.
     *
     * @param event  information about the event (not used here).
     */
    @Override
    public void axisChanged(AxisChangeEvent event) {
<span class="fc" id="L1152">        fireChangeEvent();</span>
<span class="fc" id="L1153">    }</span>

    /**
     * Receives notification of a change to the plot's dataset.
     * &lt;P&gt;
     * The plot reacts by passing on a plot change event to all registered
     * listeners.
     *
     * @param event  information about the event (not used here).
     */
    @Override
    public void datasetChanged(DatasetChangeEvent event) {
<span class="fc" id="L1165">        PlotChangeEvent newEvent = new PlotChangeEvent(this);</span>
<span class="fc" id="L1166">        newEvent.setType(ChartChangeEventType.DATASET_UPDATED);</span>
<span class="fc" id="L1167">        notifyListeners(newEvent);</span>
<span class="fc" id="L1168">    }</span>

    /**
     * Receives notification of a change to a marker that is assigned to the
     * plot.
     *
     * @param event  the event.
     */
    @Override
    public void markerChanged(MarkerChangeEvent event) {
<span class="nc" id="L1178">        fireChangeEvent();</span>
<span class="nc" id="L1179">    }</span>

    /**
     * Adjusts the supplied x-value.
     *
     * @param x  the x-value.
     * @param w1  width 1.
     * @param w2  width 2.
     * @param edge  the edge (left or right).
     *
     * @return The adjusted x-value.
     */
    protected double getRectX(double x, double w1, double w2,
                              RectangleEdge edge) {

<span class="nc" id="L1194">        double result = x;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L1196">            result = result + w1;</span>
        }
<span class="nc bnc" id="L1198" title="All 2 branches missed.">        else if (edge == RectangleEdge.RIGHT) {</span>
<span class="nc" id="L1199">            result = result + w2;</span>
        }
<span class="nc" id="L1201">        return result;</span>

    }

    /**
     * Adjusts the supplied y-value.
     *
     * @param y  the x-value.
     * @param h1  height 1.
     * @param h2  height 2.
     * @param edge  the edge (top or bottom).
     *
     * @return The adjusted y-value.
     */
    protected double getRectY(double y, double h1, double h2,
                              RectangleEdge edge) {

<span class="nc" id="L1218">        double result = y;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L1220">            result = result + h1;</span>
        }
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        else if (edge == RectangleEdge.BOTTOM) {</span>
<span class="nc" id="L1223">            result = result + h2;</span>
        }
<span class="nc" id="L1225">        return result;</span>

    }

    /**
     * Tests this plot for equality with another object.
     *
     * @param obj  the object ({@code null} permitted).
     *
     * @return {@code true} or {@code false}.
     */
    @Override
    public boolean equals(Object obj) {
<span class="fc bfc" id="L1238" title="All 2 branches covered.">        if (obj == this) {</span>
<span class="fc" id="L1239">            return true;</span>
        }
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">        if (!(obj instanceof Plot)) {</span>
<span class="nc" id="L1242">            return false;</span>
        }
<span class="fc" id="L1244">        Plot that = (Plot) obj;</span>
        // fix the &quot;equals not symmetric&quot; problem
<span class="fc bfc" id="L1246" title="All 2 branches covered.">        if (!that.canEqual(this)) {</span>
<span class="fc" id="L1247">            return false;</span>
        }
<span class="fc bfc" id="L1249" title="All 2 branches covered.">        if (!Objects.equals(this.noDataMessage, that.noDataMessage)) {</span>
<span class="fc" id="L1250">            return false;</span>
        }
<span class="fc bfc" id="L1252" title="All 2 branches covered.">        if (!Objects.equals(</span>
            this.noDataMessageFont, that.noDataMessageFont
        )) {
<span class="fc" id="L1255">            return false;</span>
        }
<span class="fc bfc" id="L1257" title="All 2 branches covered.">        if (!PaintUtils.equal(this.noDataMessagePaint,</span>
                that.noDataMessagePaint)) {
<span class="fc" id="L1259">            return false;</span>
        }
<span class="fc bfc" id="L1261" title="All 2 branches covered.">        if (!Objects.equals(this.insets, that.insets)) {</span>
<span class="fc" id="L1262">            return false;</span>
        }
        // There's a reason chart is not included in equals/hashCode - doing so
        // causes a StackOverflow error during EqualsVerifier's test!
//        if (!Objects.equals(this.chart, that.chart)) {
//            return false;
//        }
<span class="fc bfc" id="L1269" title="All 2 branches covered.">        if (this.outlineVisible != that.outlineVisible) {</span>
<span class="fc" id="L1270">            return false;</span>
        }
<span class="fc bfc" id="L1272" title="All 2 branches covered.">        if (!Objects.equals(this.outlineStroke, that.outlineStroke)) {</span>
<span class="fc" id="L1273">            return false;</span>
        }
<span class="fc bfc" id="L1275" title="All 2 branches covered.">        if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) {</span>
<span class="fc" id="L1276">            return false;</span>
        }
<span class="fc bfc" id="L1278" title="All 2 branches covered.">        if (!PaintUtils.equal(this.backgroundPaint, that.backgroundPaint)) {</span>
<span class="fc" id="L1279">            return false;</span>
        }
<span class="fc bfc" id="L1281" title="All 2 branches covered.">        if (!Objects.equals(this.backgroundImage, that.backgroundImage)) {</span>
<span class="fc" id="L1282">            return false;</span>
        }
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        if (this.backgroundImageAlignment != that.backgroundImageAlignment) {</span>
<span class="fc" id="L1285">            return false;</span>
        }
<span class="fc bfc" id="L1287" title="All 2 branches covered.">        if (Float.compare(this.backgroundImageAlpha,</span>
                          that.backgroundImageAlpha) != 0 ){
<span class="fc" id="L1289">            return false;</span>
        }
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if (Float.compare(this.foregroundAlpha, that.foregroundAlpha) != 0 ) {</span>
<span class="fc" id="L1292">            return false;</span>
        }
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        if (Float.compare(this.backgroundAlpha, that.backgroundAlpha) != 0 ) {</span>
<span class="fc" id="L1295">            return false;</span>
        }
<span class="fc bfc" id="L1297" title="All 2 branches covered.">        if (!Objects.equals(this.drawingSupplier, that.drawingSupplier)) {</span>
<span class="fc" id="L1298">            return false;</span>
        }
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        if (this.notify != that.notify) {</span>
<span class="fc" id="L1301">            return false;</span>
        }
<span class="fc bfc" id="L1303" title="All 2 branches covered.">        if (!Objects.equals(this.datasetGroup, that.datasetGroup)) {</span>
<span class="fc" id="L1304">            return false;</span>
        }
<span class="fc" id="L1306">        return true;</span>
    }

    /**
     * Ensures symmetry between super/subclass implementations of equals. For
     * more detail, see http://jqno.nl/equalsverifier/manual/inheritance.
     *
     * @param other Object
     * 
     * @return true ONLY if the parameter is THIS class type
     */
    public boolean canEqual(Object other) {
        // Solves Problem: equals not symmetric
<span class="fc" id="L1319">        return (other instanceof Plot);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1324">        int hash = 7;</span>
<span class="fc" id="L1325">        hash = 41 * hash + Objects.hashCode(this.noDataMessage);</span>
<span class="fc" id="L1326">        hash = 41 * hash + Objects.hashCode(this.noDataMessageFont);</span>
<span class="fc" id="L1327">        hash = 41 * hash + Objects.hashCode(this.noDataMessagePaint);</span>
<span class="fc" id="L1328">        hash = 41 * hash + Objects.hashCode(this.insets);</span>
//        hash = 41 * hash + Objects.hashCode(this.chart);
<span class="fc bfc" id="L1330" title="All 2 branches covered.">        hash = 41 * hash + (this.outlineVisible ? 1 : 0);</span>
<span class="fc" id="L1331">        hash = 41 * hash + Objects.hashCode(this.outlineStroke);</span>
<span class="fc" id="L1332">        hash = 41 * hash + Objects.hashCode(this.outlinePaint);</span>
<span class="fc" id="L1333">        hash = 41 * hash + Objects.hashCode(this.backgroundPaint);</span>
<span class="fc" id="L1334">        hash = 41 * hash + Objects.hashCode(this.backgroundImage);</span>
<span class="fc" id="L1335">        hash = 41 * hash + this.backgroundImageAlignment;</span>
<span class="fc" id="L1336">        hash = 41 * hash + Float.floatToIntBits(this.backgroundImageAlpha);</span>
<span class="fc" id="L1337">        hash = 41 * hash + Float.floatToIntBits(this.foregroundAlpha);</span>
<span class="fc" id="L1338">        hash = 41 * hash + Float.floatToIntBits(this.backgroundAlpha);</span>
<span class="fc" id="L1339">        hash = 41 * hash + Objects.hashCode(this.drawingSupplier);</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">        hash = 41 * hash + (this.notify ? 1 : 0);</span>
<span class="fc" id="L1341">        hash = 41 * hash + Objects.hashCode(this.datasetGroup);</span>
<span class="fc" id="L1342">        return hash;</span>
    }
    
    /**
     * Creates a clone of the plot.
     *
     * @return A clone.
     *
     * @throws CloneNotSupportedException if some component of the plot does not
     *         support cloning.
     */
    @Override
    public Object clone() throws CloneNotSupportedException {

<span class="fc" id="L1356">        Plot clone = (Plot) super.clone();</span>
        // private Plot parent &lt;-- don't clone the parent plot, but take care
        // childs in combined plots instead
<span class="pc bpc" id="L1359" title="1 of 2 branches missed.">        if (this.datasetGroup != null) {</span>
<span class="nc" id="L1360">            clone.datasetGroup</span>
<span class="nc" id="L1361">                = (DatasetGroup) ObjectUtils.clone(this.datasetGroup);</span>
        }
<span class="fc" id="L1363">        clone.drawingSupplier</span>
<span class="fc" id="L1364">            = (DrawingSupplier) ObjectUtils.clone(this.drawingSupplier);</span>
<span class="fc" id="L1365">        clone.listenerList = new EventListenerList();</span>
<span class="fc" id="L1366">        return clone;</span>

    }

    /**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
<span class="fc" id="L1378">        stream.defaultWriteObject();</span>
<span class="fc" id="L1379">        SerialUtils.writePaint(this.noDataMessagePaint, stream);</span>
<span class="fc" id="L1380">        SerialUtils.writeStroke(this.outlineStroke, stream);</span>
<span class="fc" id="L1381">        SerialUtils.writePaint(this.outlinePaint, stream);</span>
        // backgroundImage
<span class="fc" id="L1383">        SerialUtils.writePaint(this.backgroundPaint, stream);</span>
<span class="fc" id="L1384">    }</span>

    /**
     * Provides serialization support.
     *
     * @param stream  the input stream.
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException {
<span class="fc" id="L1396">        stream.defaultReadObject();</span>
<span class="fc" id="L1397">        this.noDataMessagePaint = SerialUtils.readPaint(stream);</span>
<span class="fc" id="L1398">        this.outlineStroke = SerialUtils.readStroke(stream);</span>
<span class="fc" id="L1399">        this.outlinePaint = SerialUtils.readPaint(stream);</span>
        // backgroundImage
<span class="fc" id="L1401">        this.backgroundPaint = SerialUtils.readPaint(stream);</span>

<span class="fc" id="L1403">        this.listenerList = new EventListenerList();</span>

<span class="fc" id="L1405">    }</span>

    /**
     * Resolves a domain axis location for a given plot orientation.
     *
     * @param location  the location ({@code null} not permitted).
     * @param orientation  the orientation ({@code null} not permitted).
     *
     * @return The edge (never {@code null}).
     */
    public static RectangleEdge resolveDomainAxisLocation(
            AxisLocation location, PlotOrientation orientation) {

<span class="fc" id="L1418">        Args.nullNotPermitted(location, &quot;location&quot;);</span>
<span class="fc" id="L1419">        Args.nullNotPermitted(orientation, &quot;orientation&quot;);</span>

<span class="fc" id="L1421">        RectangleEdge result = null;</span>
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">        if (location == AxisLocation.TOP_OR_RIGHT) {</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1424">                result = RectangleEdge.RIGHT;</span>
            }
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L1427">                result = RectangleEdge.TOP;</span>
            }
        }
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">        else if (location == AxisLocation.TOP_OR_LEFT) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1432">                result = RectangleEdge.LEFT;</span>
            }
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L1435">                result = RectangleEdge.TOP;</span>
            }
        }
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1440">                result = RectangleEdge.RIGHT;</span>
            }
<span class="nc bnc" id="L1442" title="All 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L1443">                result = RectangleEdge.BOTTOM;</span>
            }
        }
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">        else if (location == AxisLocation.BOTTOM_OR_LEFT) {</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="fc" id="L1448">                result = RectangleEdge.LEFT;</span>
            }
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="fc" id="L1451">                result = RectangleEdge.BOTTOM;</span>
            }
        }
        // the above should cover all the options...
<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L1456">            throw new IllegalStateException(&quot;resolveDomainAxisLocation()&quot;);</span>
        }
<span class="fc" id="L1458">        return result;</span>

    }

    /**
     * Resolves a range axis location for a given plot orientation.
     *
     * @param location  the location ({@code null} not permitted).
     * @param orientation  the orientation ({@code null} not permitted).
     *
     * @return The edge (never {@code null}).
     */
    public static RectangleEdge resolveRangeAxisLocation(
            AxisLocation location, PlotOrientation orientation) {

<span class="fc" id="L1473">        Args.nullNotPermitted(location, &quot;location&quot;);</span>
<span class="fc" id="L1474">        Args.nullNotPermitted(orientation, &quot;orientation&quot;);</span>

<span class="fc" id="L1476">        RectangleEdge result = null;</span>
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">        if (location == AxisLocation.TOP_OR_RIGHT) {</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1479">                result = RectangleEdge.TOP;</span>
            }
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L1482">                result = RectangleEdge.RIGHT;</span>
            }
        }
<span class="fc bfc" id="L1485" title="All 2 branches covered.">        else if (location == AxisLocation.TOP_OR_LEFT) {</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="fc" id="L1487">                result = RectangleEdge.TOP;</span>
            }
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="fc" id="L1490">                result = RectangleEdge.LEFT;</span>
            }
        }
<span class="pc bpc" id="L1493" title="1 of 2 branches missed.">        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1495">                result = RectangleEdge.BOTTOM;</span>
            }
<span class="nc bnc" id="L1497" title="All 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="nc" id="L1498">                result = RectangleEdge.RIGHT;</span>
            }
        }
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">        else if (location == AxisLocation.BOTTOM_OR_LEFT) {</span>
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">            if (orientation == PlotOrientation.HORIZONTAL) {</span>
<span class="nc" id="L1503">                result = RectangleEdge.BOTTOM;</span>
            }
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">            else if (orientation == PlotOrientation.VERTICAL) {</span>
<span class="fc" id="L1506">                result = RectangleEdge.LEFT;</span>
            }
        }

        // the above should cover all the options...
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L1512">            throw new IllegalStateException(&quot;resolveRangeAxisLocation()&quot;);</span>
        }
<span class="fc" id="L1514">        return result;</span>

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>